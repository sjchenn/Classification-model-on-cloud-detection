number = 10
)
svm_fit <- train(expert_labels ~ NDAI + SD + CORR + DF, data = train_data,
method = "svmLinear",
trControl = fitControl,
tuneGrid = expand.grid(C = seq(0.2, 2, length = 5)),
preProcess = c("center","scale"))
set.seed(521)
fitControl <- trainControl(## 10-fold CV
method = "cv",
number = 10
)
svm_fit <- train(expert_labels ~ NDAI + SD + CORR + DF, data = train_data,
method = "svmLinear",
trControl = fitControl,
tuneGrid = expand.grid(C = seq(0.2, 2, length = 5)),
preProcess = c("center","scale"))
control <- trainControl(method='repeatedcv',
number=10,
repeats=3,
search = 'random')
rf_fit <- train(expert_labels ~ NDAI + SD + CORR + DF, data = train_data,
method = "rf",
metric = 'Accuracy',
#tuneLength  = 15,
#  trControl = control
)
library(randomForest)
rf_fit <- randomForest(expert_labels ~ NDAI + SD +CORR + DF , data = train_data, ntree = 20, mtry = 4, importance = T)
plot(rf_fit)
control <- trainControl(method='cv',
number=10,
repeats=3,
search = 'random')
rf_fit <- train(expert_labels ~ NDAI + SD + CORR + DF, data = train_data,
method = "nnet",
metric = 'Accuracy',
#tuneLength  = 15,
trControl = control,
linout = T
)
control <- trainControl(method='cv',
number=10,
repeats=3,
search = 'random')
rf_fit <- train(expert_labels ~ NDAI + SD + CORR + DF, data = train_data,
method = "nnet",
metric = 'Accuracy',
#tuneLength  = 15,
trControl = control
#  linout = T
)
rf_fit
rf_fit$results
pred(rf_fit,test_data)
predict(rf_fit,test_data)
predicted == test_data$expert_labels
predicted = predict(rf_fit,test_data)
predicted == test_data$expert_labels
sum(predicted == test_data$expert_labels)/nrow(test_data)
predicted = predict(rf_fit,test_data)
sum(predicted == test_data$expert_labels)/nrow(test_data)
library(tidyverse)
library(shiny)
library(RSQLite)
library(DBI)
library(tidyquery)
library(reactable)
library(data.table)
# first connect to db and grab unique course and dept list for drop-down
db <- dbConnect(
SQLite(),
here::here("data/gradebook.sqlite")
)
library(tidyverse)
library(shiny)
library(RSQLite)
library(DBI)
library(tidyquery)
library(reactable)
library(data.table)
library(tidyverse)
library(shiny)
library(kableExtra)
library(DBI)
library(GGally)
library(shinythemes)
# Create a function to run the Gradebook app
run_gradebook = function() {
# Initialize the generation of the shinyapp obkect
shinyApp(
# Set up the user interface
ui = fluidPage(
# Set the theme to "united" to change colors and fonts
theme = shinytheme("united"),
# Give titlePanel a name
titlePanel("Gradebook"),
# Put all elements of interest into the main panel
mainPanel(h1("User Input"),
# Allow for selection of department
selectInput("dep", h3("Select Department"),
choices = list("Literature" = "lit",
"History" = "hist",
"Mathematics" = "math",
"Statistics" = "stat",
"Biology" = "bio",
"Physics" = "phys",
"All Departments" = "all"),
selected = "lit"),
# Allow for selection of class within department (default)
radioButtons("class", h3("Select Class"),
choices = list("120" = 120,
"264" = 264,
"272" = 272,
"354" = 354,
"401" = 401)),
# Let user choose if they want to include final grade
checkboxInput("fingrade", "Include Final Grade?"),
# Only show Letter grade choice if final grade selected
conditionalPanel(
condition = "input.fingrade",
checkboxInput("letgrade", "Include Letter Grade?")
),
# Only show each panel for specific department, or if a class has
# been chosen from "all classes" that is in department
# First, the Literature department
conditionalPanel(
condition = "input.fingrade && input.dep == 'lit'||
input.dep == 'all' && (/lit/).test(input.class) && input.fingrade",
sliderInput("exam_lit", "Weight for Exams",
min = 0, max = 1, value = .5),
sliderInput("paper_lit", "Weight for Papers",
min = 0, max = 1, value = .5)),
# Now a panel for History
conditionalPanel(
condition = "input.fingrade && input.dep == 'hist' ||
input.dep == 'all' && (/hist/).test(input.class) && input.fingrade",
sliderInput("exam_hist", "Weight for Exams",
min = 0, max = 1, value = .4),
sliderInput("paper_hist", "Weight for Papers",
min = 0, max = 1, value = .3),
sliderInput("project_hist", "Weight for Projects",
min = 0, max = 1, value = .3)),
# Next a panel for Math
conditionalPanel(
condition = "input.fingrade && input.dep == 'math' ||
input.dep == 'all' && (/math/).test(input.class) && input.fingrade",
sliderInput("exam_math", "Weight for Exams",
min = 0, max = 1, value = .5),
sliderInput("hw_math", "Weight for Homework",
min = 0, max = 1, value = .5)),
# Next, a panel for Statistics
conditionalPanel(
condition = "input.fingrade && input.dep == 'stat' ||
input.dep == 'all' && (/stat/).test(input.class) && input.fingrade",
sliderInput("exam_stat", "Weight for Exams",
min = 0, max = 1, value = .4),
sliderInput("hw_stat", "Weight for Homework",
min = 0, max = 1, value = .3),
sliderInput("project_stat", "Weight for Projects",
min = 0, max = 1, value = .3)),
# Panel for Biology
conditionalPanel(
condition = "input.fingrade && input.dep == 'bio' ||
input.dep == 'all' && (/bio/).test(input.class) && input.fingrade",
sliderInput("exam_bio", "Weight for Exams",
min = 0, max = 1, value = .4),
sliderInput("lab_bio", "Weight for Labs",
min = 0, max = 1, value = .3),
sliderInput("project_bio", "Weight for Projects",
min = 0, max = 1, value = .3)),
# And finally, a panel for physics
conditionalPanel(
condition = "input.fingrade && input.dep == 'phys' ||
input.dep == 'all' && (/phys/).test(input.class) && input.fingrade",
sliderInput("exam_phys", "Weight for Exams",
min = 0, max = 1, value = .4),
sliderInput("hw_phys", "Weight for Homework",
min = 0, max = 1, value = .3),
sliderInput("lab_phys", "Weight for Labs",
min = 0, max = 1, value = .3)),
# Conditionally, show the sliders for Grade Cut-offs
conditionalPanel(
condition = "input.letgrade && input.fingrade",
sliderInput("a_cut", "Cutoff for an A grade",
min = 0, max = 1, value = .9),
sliderInput("b_cut", "Cutoff for a B grade",
min = 0, max = 1, value = .8),
sliderInput("c_cut", "Cutoff for a C grade",
min = 0, max = 1, value = .7)
),
# Action button to generate the report
actionButton("go", "Go"),
# Action button to make corrections
actionButton("correct", "Make Corrections"),
# Conditional panel to show the results of the table/visualizations
conditionalPanel(
condition = "input.go",
h1("Tabulated Results of Produced Report"),
tableOutput("OutputTable"),
h1("Visualization of Grade Distributions"),
plotOutput("GradeDistribution")
),
# Make a plot of final grade distributions
conditionalPanel(
condition = "input.fingrade && !input.letgrade",
plotOutput("fingrade_dis")
),
# Make a plot of final grade distributions with grade cut-offs
conditionalPanel(
condition = "input.fingrade && input.letgrade",
plotOutput("fin_let_dis")
)
)
),
# Now we get into the logic of generating the report
server = function(input, output, session) {
# Tie observation to department being changed
# Should update even without a data query being run
observe({
# Depending on selected department, change the courses listed
if (input$dep == "lit") {
new_choices <- list(120, 264, 272, 354, 401)
} else if (input$dep == "hist") {
new_choices <- list(207, 381, 436, 444)
} else if (input$dep == "math") {
new_choices <- list(212, 238, 408)
} else if (input$dep == "stat") {
new_choices <- list(226, 376, 423)
} else if (input$dep == "bio") {
new_choices <- list(285, 328)
} else if (input$dep == "phys") {
new_choices <- list(373, 456, 459)
} else if (input$dep == "all") {
# Special logic for the "all classes" logic
new_choices <- list("lit 120", "hist 207", "math 212", "stat 226",
"math 238", "lit 264", "lit 272", "bio 285",
"bio 328", "lit 354")
} else {
# Sanity check
warning("Something has gone wrong with departmental selection")
}
# Update what is shown to the user
updateRadioButtons(session, inputId = "class",
choices = new_choices)
}) %>%
bindEvent(input$dep)
# Now produce the table when the user clicks "Go"
# This is executed through three calls to the databases:
# gradebook, corrections, and assignments for the weights
table <- eventReactive(input$go, {
# Access the minimum amount of data possible
x <- as.tibble(DBI::dbConnect(RSQLite::SQLite(), "data/gradebook.sqlite") %>%
dplyr::tbl("gradebook") %>%
filter(class == local(ifelse(input$dep != "all",
paste(input$dep, input$class),
input$class))) %>%
dplyr::arrange(assignment) %>%
pivot_wider(names_from = assignment, values_from = points))
# Access the corrections to see what needs to be shown
# Where corrections override
db = dbConnect(RSQLite::SQLite(), "data/corrections.sqlite")
# check if correction table exists
if ("corrections" %in% dbListTables(db)){
if (input$dep == "all"){
correction_table <- dbReadTable(db, "corrections")
} else {
# If it doesn't, create a new data base
sql_state_query <- "SELECT * FROM corrections WHERE Department = '@' AND Class = '@'"
statement_comp <- strsplit(sql_state_query, split = "@")
sql_state_query <- paste0(statement_comp[[1]][1], input$dep,
statement_comp[[1]][2], input$class,
statement_comp[[1]][3])
correction_table <- dbGetQuery(conn = db,
sql_state_query)
}
# If there is a discrepancy, default to corrected value
if (!identical(row.names(correction_table), character(0))){
for (i in 1:nrow(correction_table)){
student_name <- correction_table[i, 3]
#print(student_name)
assignments <- correction_table[i, 4]
#print(assignments)
new_point <- correction_table[i, 5]
x[x$student == student_name, ][assignments] <- new_point
}
}
}
# Disconnect once completed
dbDisconnect(db)
# If the user has asked for a final grade to be calculated
if (input$fingrade) {
# Depending on department, use different sliders to calculate
# the total weights. This section makes sure that all of the weights
# add up to one and throws a warning to the user if they don't
if (input$dep == "math" & input$fingrade | input$dep == "all" &
length(grep("math", input$class)) >= 1) {
out <- sum(input$exam_math, input$hw_math)
}
if (input$dep == "hist" & input$fingrade | input$dep == "all" &
length(grep("hist", input$class)) >= 1) {
out <- sum(input$exam_hist, input$paper_hist, input$project_hist)
}
if (input$dep == "stat" & input$fingrade | input$dep == "all" &
length(grep("stat", input$class)) >= 1) {
out <- sum(input$exam_stat, input$hw_stat, input$project_stat)
}
if (input$dep == "lit" & input$fingrade | input$dep == "all" &
length(grep("lit", input$class)) >= 1) {
out <- sum(input$exam_lit, input$paper_lit)
}
if (input$dep == "bio" & input$fingrade | input$dep == "all" &
length(grep("bio", input$class)) >= 1) {
out <- sum(input$exam_bio, input$project_bio, input$lab_bio)
}
if (input$dep == "phys" & input$fingrade | input$dep == "all" &
length(grep("phys", input$class)) >= 1) {
out <- sum(input$exam_phys, input$lab_phys, input$hw_phys)
}
# Validation will warn if sum of weights != 1
validate(need(out == 1, "Please make sure all weights sum up to 1"))
# Now we begin the calculation of the final grade if we have appripriate weights
# First, access the different assignment point totals
z <- as.tibble(DBI::dbConnect(RSQLite::SQLite(), "data/gradebook.sqlite") %>%
dplyr::tbl("assignments") %>%
filter(class == local(ifelse(input$dep != "all",
paste(input$dep, input$class),
input$class))))
# Substitute out the numeric aspects to get a list of assignment types
z$assign_type <- as.factor(gsub("[0-9]", "", z$assignment))
# Initialize the weights as zero
z$weight <- NA
# For every now calculate the weight of each assignment
for (i in 1:nrow(z)) {
z$weight[i] <- z$total_pts[i] / sum(z$total_pts[z$assign_type == z$assign_type[i]])
}
# Replicate the scores for each assignment in a matrix
scores <- matrix(nrow = nrow(x), ncol = ncol(x))
# Create a temporary frame where NA values are replaced by zeros
x_replace <- x
x_replace[is.na(x_replace)] <- 0
# For each assignment, calculate its contribution to the final score
for (i in 1:nrow(x)) {
for (j in 3:ncol(x)) {
# First, get the raw score
scores[i, j] <- as.double(x_replace[i, j]) /
# Then, divide by the total possible points
as.double(z$total_pts[z$assignment == colnames(x)[j]]) *
# Multiply by the relative weight of each assignment
z$weight[z$assignment == colnames(x)[j]] *
# Then multiply by the user-input type weight
input[[paste0(as.character(z$assign_type[z$assignment == colnames(x)[j]]), "_",
ifelse(input$dep == "all",
gsub("[^a-zA-Z]", "", input$class),
input$dep))]]
}
}
# Calculate final grades as row sums
final_grades <- rowSums(scores[, 3:ncol(scores)])
# Attach final grades to the output when relevant
x <- cbind(x, final_grades)
}
# If the user wants a letter grade as well
if (input$letgrade) {
# Make sure A > B > C cut-off
validate(need(input$a_cut > input$b_cut & input$b_cut > input$c_cut,
"Make sure that A grades > B grades > C grades"))
# Set each letter grade
x$LetterGrade <- NA
x$LetterGrade[x$final_grades < input$c_cut] <- "D"
x$LetterGrade[x$final_grades > input$c_cut & x$final_grades < input$b_cut] <- "C"
x$LetterGrade[x$final_grades > input$b_cut & x$final_grades < input$a_cut] <- "B"
x$LetterGrade[x$final_grades > input$a_cut] <- "A"
}
# Return the data frame to table() object
x
})
# Output the table to the UI
output$OutputTable <- renderTable(na = "Assignment Missing", {
table()
})
# Output the summary plots for all numeric columns
output$GradeDistribution <- renderPlot({
ggpairs(table()[, sapply(table(), is.numeric)])
})
# Output the overall grade distribution
output$fingrade_dis <- renderPlot({
ggplot(table()) + geom_density(aes(x = final_grades), size = 2, col = "red",
fill = "lightblue") +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black"),
panel.margin = unit(c(0, 0, 0, 0), "cm")) +
labs(title = "Distribution of Student Grades", x = "Final Grade",
y = "Density")
})
# Output the overall grade distribution when there are grades
output$fin_let_dis <- renderPlot({
ggplot(table()) + geom_density(aes(x = final_grades), size = 2, col = "red",
fill = "lightblue") +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black"),
panel.margin = unit(c(0, 0, 0, 0), "cm")) +
labs(title = "Distribution of Student Grades", x = "Final Grade",
y = "Density") +
annotate(geom = "vline",
x = c(input$a_cut, input$b_cut, input$c_cut),
xintercept = c(input$a_cut, input$b_cut, input$c_cut),
linetype = c("dashed", "dashed", "dashed"),
color = c("Green", "Yellow", "Red"),
size = c(1.5, 1.5, 1.5)) +
annotate(geom = "text",
label = c("Cut-off for A", "Cut-off for B", "Cut-off for C"),
x = c(input$a_cut, input$b_cut, input$c_cut),
y = c(5,5,5),
angle = 90,
vjust = 1)
})
# When the user asks to correct data
observeEvent(input$correct, {
dat <- table()%>%
select(-student,-class)
# Run the modal dialog
showModal(modalDialog(
# Allow for selection of student
selectInput("student", "Student Name", c(sort(unique(table()$student)))),
# Allow for selection of assignment
selectInput("assignment_rep", "Assignment",c(sort(unique(colnames(dat))))),
uiOutput("score"),
footer = tagList(
# Buttons to submit changes and leave editing phase
modalButton("Leave"),
actionButton("submit", "Submit")
)
))
# Render the interface
output$score <- renderUI({
db = dbConnect(RSQLite::SQLite(), "data/gradebook.sqlite")
# Read in the assignments
assignments <- dbReadTable(db, "assignments")
# Figure out what the current points are for the assignment
current_point <- as.numeric(table() %>% filter(student == !!input$student) %>%
select(input$assignment_rep))
# Figure out the total points possible for the assignment
total_point <- assignments[assignments$class == paste0(input$dep, " ", input$class) &
assignments$assignment == input$assignment_rep, 3]
# check if the current point is missing
if (is.na(current_point)) {
sliderInput("point", "Corrected Score", value = 0, min = 0,
max = total_point, step = 1)
} else {
sliderInput("point", "Corrected Score", value = current_point,
min = 0, max = total_point, step = 1)
}
})
})
# When the user presses submit
observeEvent(input$submit,{
# connect to correction db
db = dbConnect(RSQLite::SQLite(), "data/corrections.sqlite")
# If there is not a corrections table already, create one
if (!"corrections" %in% dbListTables(db)){
dbSendQuery(conn = db,
"CREATE TABLE corrections (Department TEXT,
Class TEXT,
Name TEXT,
Assignment TEXT,
Points INTEGER)")
}
# Select the points from the right department, class, name, and assignment
sql_state_query <- "SELECT Points FROM corrections WHERE Department = '@' AND Class = '@' AND Name = '@' AND Assignment = '@'"
statement_comp <- strsplit(sql_state_query, split = "@")
# Generate the SQL query
sql_state_query <- paste0(statement_comp[[1]][1], input$dep,
statement_comp[[1]][2], input$class,
statement_comp[[1]][3], input$student,
statement_comp[[1]][4], input$assignment_rep,
statement_comp[[1]][5])
# Get the query
x = dbGetQuery(db, sql_state_query)
# check if "similar" record exists
if (identical(unlist(x), integer(0))){
sql_state_insert <- "INSERT INTO corrections VALUES ('@', '@', '@', '@', @)"
statement_comp <- strsplit(sql_state_insert, split = "@")
sql_state_insert <- paste0(statement_comp[[1]][1], input$dep,
statement_comp[[1]][2], input$class,
statement_comp[[1]][3], input$student,
statement_comp[[1]][4], input$assignment_rep,
statement_comp[[1]][5], input$point,
statement_comp[[1]][6])
dbSendQuery(conn = db, statement = sql_state_insert)
} else {
sql_state_update <- "UPDATE corrections
SET Points = @
WHERE Department = '@' AND
Class = '@' AND
Name = '@' AND
Assignment = '@'"
statement_comp <- strsplit(sql_state_update, split = "@")
sql_state_update <- paste0(statement_comp[[1]][1], input$point,
statement_comp[[1]][2], input$dep,
statement_comp[[1]][3], input$class,
statement_comp[[1]][4], input$student,
statement_comp[[1]][5], input$assignment_rep,
statement_comp[[1]][6])
dbSendQuery(conn = db, sql_state_update)
}
})
}
)
}
# Run the completed application
run_gradebook()
